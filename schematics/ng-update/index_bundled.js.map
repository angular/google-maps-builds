{
  "version": 3,
  "sources": ["../../../../../../../src/google-maps/schematics/ng-update/index.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Path} from '@angular-devkit/core';\nimport {Rule, Tree} from '@angular-devkit/schematics';\nimport ts from 'typescript';\n\n/** Tag name of the clusterer component. */\nconst TAG_NAME = 'map-marker-clusterer';\n\n/** Module from which the clusterer is being imported. */\nconst MODULE_NAME = '@angular/google-maps';\n\n/** Old name of the clusterer class. */\nconst CLASS_NAME = 'MapMarkerClusterer';\n\n/** New name of the clusterer class. */\nconst DEPRECATED_CLASS_NAME = 'DeprecatedMapMarkerClusterer';\n\n/** Entry point for the migration schematics with target of Angular Material v19 */\nexport function updateToV19(): Rule {\n  return tree => {\n    tree.visit(path => {\n      if (path.includes('node_modules')) {\n        return;\n      }\n\n      if (path.endsWith('.html')) {\n        const content = tree.read(path)?.toString();\n\n        if (content && content.includes('<' + TAG_NAME)) {\n          tree.overwrite(path, migrateHtml(content));\n        }\n      } else if (path.endsWith('.ts') && !path.endsWith('.d.ts')) {\n        migrateTypeScript(path, tree);\n      }\n    });\n  };\n}\n\n/** Migrates an HTML template from the old tag name to the new one. */\nfunction migrateHtml(content: string): string {\n  return content\n    .replace(/<map-marker-clusterer/g, '<deprecated-map-marker-clusterer')\n    .replace(/<\\/map-marker-clusterer/g, '</deprecated-map-marker-clusterer');\n}\n\n/** Migrates a TypeScript file from the old tag and class names to the new ones. */\nfunction migrateTypeScript(path: Path, tree: Tree) {\n  const content = tree.read(path)?.toString();\n\n  // Exit early if none of the symbols we're looking for are mentioned.\n  if (\n    !content ||\n    (!content.includes('<' + TAG_NAME) &&\n      !content.includes(MODULE_NAME) &&\n      !content.includes(CLASS_NAME))\n  ) {\n    return;\n  }\n\n  const sourceFile = ts.createSourceFile(path, content, ts.ScriptTarget.Latest, true);\n  const toMigrate = findTypeScriptNodesToMigrate(sourceFile);\n\n  if (toMigrate.length === 0) {\n    return;\n  }\n\n  const printer = ts.createPrinter();\n  const update = tree.beginUpdate(path);\n\n  for (const node of toMigrate) {\n    let replacement: ts.Node;\n\n    if (ts.isStringLiteralLike(node)) {\n      // Strings should be migrated as if they're HTML.\n      if (ts.isStringLiteral(node)) {\n        replacement = ts.factory.createStringLiteral(\n          migrateHtml(node.text),\n          node.getText()[0] === `'`,\n        );\n      } else {\n        replacement = ts.factory.createNoSubstitutionTemplateLiteral(migrateHtml(node.text));\n      }\n    } else {\n      // Imports/exports should preserve the old name, but import the clusterer using the new one.\n      const propertyName = ts.factory.createIdentifier(DEPRECATED_CLASS_NAME);\n      const name = node.name as ts.Identifier;\n\n      replacement = ts.isImportSpecifier(node)\n        ? ts.factory.updateImportSpecifier(node, node.isTypeOnly, propertyName, name)\n        : ts.factory.updateExportSpecifier(node, node.isTypeOnly, propertyName, name);\n    }\n\n    update\n      .remove(node.getStart(), node.getWidth())\n      .insertLeft(\n        node.getStart(),\n        printer.printNode(ts.EmitHint.Unspecified, replacement, sourceFile),\n      );\n  }\n\n  tree.commitUpdate(update);\n}\n\n/** Finds the TypeScript nodes that need to be migrated from a specific file. */\nfunction findTypeScriptNodesToMigrate(sourceFile: ts.SourceFile) {\n  const results: (ts.StringLiteralLike | ts.ImportSpecifier | ts.ExportSpecifier)[] = [];\n\n  sourceFile.forEachChild(function walk(node) {\n    // Most likely a template using the clusterer.\n    if (ts.isStringLiteral(node) && node.text.includes('<' + TAG_NAME)) {\n      results.push(node);\n    } else if (\n      // Import/export referencing the clusterer.\n      (ts.isImportDeclaration(node) || ts.isExportDeclaration(node)) &&\n      node.moduleSpecifier &&\n      ts.isStringLiteralLike(node.moduleSpecifier) &&\n      node.moduleSpecifier.text === MODULE_NAME\n    ) {\n      const bindings = ts.isImportDeclaration(node)\n        ? node.importClause?.namedBindings\n        : node.exportClause;\n\n      if (bindings && (ts.isNamedImports(bindings) || ts.isNamedExports(bindings))) {\n        bindings.elements.forEach(element => {\n          const symbolName = element.propertyName || element.name;\n\n          if (ts.isIdentifier(symbolName) && symbolName.text === CLASS_NAME) {\n            results.push(element);\n          }\n        });\n      }\n    } else {\n      node.forEachChild(walk);\n    }\n  });\n\n  // Sort the results in reverse order to make applying the updates easier.\n  return results.sort((a, b) => b.getStart() - a.getStart());\n}\n"],
  "mappings": "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",
  "names": ["ts"]
}
